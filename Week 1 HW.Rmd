---
title: "R Notebook"
output: html_notebook
---

HW at: <https://github.com/rmcelreath/stat_rethinking_2022/blob/main/homework/week01.pdf>

```{r}
#library(rethinking)
library(flextable)
library(tidyverse)
library(brms)

```

# (Not HW: Coding the Marble Example)

"Suppose there's a bag, and it contains four marbles. These marbles come in two colors: blue and white. We know there are four marbles in the bag, but we don't know how many there are of each color."

We are going to draw three marbles, with replacement, and based upon what we find out, we are going to make a guess about what the actual distribution of marbles is in the bag. We'll use a Bayesian modeling approach to do this. The approach is like so:

1.  Create a story of how the data might arise - the initial model
2.  Update the model with gathered data
3.  Revise the model accordingly

## Step 1

So the nice thing about the marble example is marbles can only be blue and white, and there aren't that many of them, so we can just literally describe all of them, like so:

```{r}

conjectures <- tibble(conjecture = c(1:5),
                      whites = c(4, 3, 2, 1, 0),
                      blues = (0:4))

flextable(conjectures)

```

Great. We haven't gathered any data yet, so we don't know the relative likelihood of any of these possibilities ("conjectures"), but these are the possibilities.

## Step 2

So now let's encounter a datum.

The first marble we pull is a blue. (And it's not white!)

So now we can update the model with this data and get some probabilities for each conjecture.

We will write a little function to do this. Recall we are sampling from the bag with replacement so each draw doesn't affect subsequent draws.

If there's 3 blue marbles in the bag, then there's 3 ways to draw a blue, and just 1 way to draw a white.

So if you draw three blues, then the number of ways you could have ended up doing that is:

$3 * 3 * 3 = 3^{3}$

And the number of ways you could draw that one blue is $1^{1}$

And the same logic applies for other combinations.

Thus the generic count of ways is going to be:

$\text{conjectured blues} ^ {\text{observed whites}} * \text{conjectured whites} ^ {\text{observed whites}}$

And then the relative likelihood, or *plausibity*, of any given conjecture is just how many ways it contributes to the total number of ways that are available.

```{r}

update.marbles <- function(num_blues, num_whites, conjectures) {
  
  conjectures %>%
    mutate(ways = blues^num_blues * whites^num_whites,
             p = round(ways /sum(ways),2))
  
  
}

update.marbles(1, 0, conjectures) %>%
  flextable()
```

The example data given in the book is blue, white, blue, and now we can see that the procedure above generates the right number of ways and $p$s for that data.

```{r}
update.marbles(2, 1, conjectures) %>%
  flextable()
```

# Problem 1

Suppose the globe tossing data (Chapter 2) had turned out to be 4 water and 11 land. Construct the posterior distribution, using grid approximation. Use the same flat prior as in the book.

## Code for the original globe tossing dataset

Let 1 = W, 0 = L

```{r}

data <- c(1,0,1,1,1,0,1,0,1)

```

Initial prior: ??

This is "step 1": tell the story of how these data might arise

Specifically we're starting with a very basic model that states the percentage of Earth's surface that is water. This is "p"

Per the lecture it actually doesn't matter what we choose here, for now

We'll make it 50-50

```{r}

p.initial <- .5

```

Let's write the function that updates p based on one observation.

Here's Bayes's thereom:

$\text{Posterior}  = \frac{\text{Probability of the data} * \text{Prior}} {\text{Average probability of the data}}$

Remember that the prior i

```{r}

update <- function(prior, data) {
 
   # the numerator here is the 
  
}

```
